import { create } from 'zustand';
import { Project, FileNode, Variant, ConsoleLog } from '@/types';
import { mockProjects, defaultFileTree, generateMockVariants, mockConsoleLogs } from '@/lib/mockData';

interface ProjectState {
  projects: Project[];
  currentProject: Project | null;
  fileTree: FileNode[];
  selectedFile: FileNode | null;
  variants: Variant[];
  consoleLogs: ConsoleLog[];
  isGenerating: boolean;
  selectedVariant: Variant | null;

  // Actions
  setCurrentProject: (project: Project | null) => void;
  createProject: (name: string, description: string, template: string) => Project;
  deleteProject: (id: string) => void;
  selectFile: (file: FileNode | null) => void;
  updateFileContent: (fileId: string, content: string) => void;
  generateVariants: (prompt: string) => Promise<void>;
  selectVariant: (variant: Variant | null) => void;
  acceptVariant: (variant: Variant) => void;
  addConsoleLog: (log: Omit<ConsoleLog, 'id' | 'timestamp'>) => void;
  clearConsoleLogs: () => void;
}

export const useProjectStore = create<ProjectState>((set, get) => ({
  projects: mockProjects,
  currentProject: null,
  fileTree: defaultFileTree,
  selectedFile: null,
  variants: [],
  consoleLogs: mockConsoleLogs,
  isGenerating: false,
  selectedVariant: null,

  setCurrentProject: (project) => {
    set({ currentProject: project, fileTree: defaultFileTree, selectedFile: null, variants: [] });
  },

  createProject: (name, description, template) => {
    const newProject: Project = {
      id: Date.now().toString(),
      name,
      description,
      template,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    set((state) => ({ projects: [newProject, ...state.projects] }));
    return newProject;
  },

  deleteProject: (id) => {
    set((state) => ({
      projects: state.projects.filter((p) => p.id !== id),
      currentProject: state.currentProject?.id === id ? null : state.currentProject,
    }));
  },

  selectFile: (file) => set({ selectedFile: file }),

  updateFileContent: (fileId, content) => {
    const updateNode = (nodes: FileNode[]): FileNode[] => {
      return nodes.map((node) => {
        if (node.id === fileId) {
          return { ...node, content };
        }
        if (node.children) {
          return { ...node, children: updateNode(node.children) };
        }
        return node;
      });
    };
    set((state) => ({ fileTree: updateNode(state.fileTree) }));
  },

  generateVariants: async (prompt) => {
    set({ isGenerating: true, variants: [] });

    try {
      // Import AI API client
      const { aiApi } = await import('@/lib/aiApi');

      // Call real AI API
      const response = await aiApi.generateCode({
        prompt,
        temperature: 0.7,
        max_tokens: 512,
        num_variants: 3,
        style: 'lovable',
      });

      // Convert API response to our Variant format
      const variants: Variant[] = response.variants.map((v) => ({
        id: v.id,
        code: v.code,
        preview: '', // Preview will be generated by DevicePreview component
        description: v.description,
        score: v.score,
      }));

      set({ variants, isGenerating: false });
      get().addConsoleLog({
        type: 'success',
        message: `✅ Generated ${variants.length} variants using AI model`
      });

    } catch (error) {
      // Fallback to mock data if API fails
      console.error('AI API error, falling back to mock data:', error);

      const variants = generateMockVariants(prompt);
      set({ variants, isGenerating: false });

      get().addConsoleLog({
        type: 'warning',
        message: `⚠️ Using mock data (API unavailable): ${error instanceof Error ? error.message : 'Unknown error'}`
      });
    }
  },

  selectVariant: (variant) => set({ selectedVariant: variant }),

  acceptVariant: (variant) => {
    const { selectedFile, updateFileContent, addConsoleLog } = get();
    if (selectedFile && selectedFile.type === 'file') {
      updateFileContent(selectedFile.id, variant.code);
      addConsoleLog({ type: 'info', message: 'Variant accepted and applied to file' });
    }
    set({ variants: [], selectedVariant: null });
  },

  addConsoleLog: (log) => {
    const newLog: ConsoleLog = {
      ...log,
      id: Date.now().toString(),
      timestamp: new Date(),
    };
    set((state) => ({ consoleLogs: [newLog, ...state.consoleLogs].slice(0, 100) }));
  },

  clearConsoleLogs: () => set({ consoleLogs: [] }),
}));
